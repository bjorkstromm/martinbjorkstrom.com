
<!DOCTYPE html>
<!--
	Phantom by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html lang="en">

	<head>
		<title>Martin Bj&#xF6;rkstr&#xF6;m - Dissecting the Azure Service Fabric Mesh Right-Click Publish</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1" />		
        <link href="/assets/css/highlight.css" rel="stylesheet">
		<!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="/assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
        <link href="/assets/css/override.css" rel="stylesheet" />

		<meta name="description" content="Driving Digital Transformation on Serverless Containers..." />
		<link type="application/rss+xml" rel="alternate" title="Martin Bj&#xF6;rkstr&#xF6;m" href="/feed.rss" />
				<link type="application/atom+xml" rel="alternate" title="Martin Bj&#xF6;rkstr&#xF6;m" href="/feed.atom" />
		<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
		<link rel="icon" href="/favicon.ico" type="image/x-icon">

		<meta name="application-name" content="Martin Bj&#xF6;rkstr&#xF6;m" />
		<meta name="msapplication-tooltip" content="Martin Bj&#xF6;rkstr&#xF6;m" />
		<meta name="msapplication-starturl" content="/" />

		<meta property="og:title" content="Martin Bj&#xF6;rkstr&#xF6;m - Dissecting the Azure Service Fabric Mesh Right-Click Publish" /> 
		<meta property="og:type" content="website" />
		<meta property="og:url" content="http://martinbjorkstrom.com/posts/2018-10-15-dissecting-sf-mesh-vs-publish" />
		<!-- TODO: More social graph meta tags -->

        <script src="/assets/js/highlight.pack.js"></script>   
		
        

		
	</head>

	<body>
		<!-- Wrapper -->
		<div id="wrapper">

			<!-- Header -->
			<header id="header">
				<div class="inner">

					<!-- Logo -->
					<a href="/" class="logo">
						<span class="title">Martin Bj&#xF6;rkstr&#xF6;m</span>
					</a>

					<!-- Nav -->
					<nav>
						<ul>
							<li><a href="#menu">Menu</a></li>
						</ul>
					</nav>

				</div>
			</header>

			<!-- Menu -->
			<nav id="menu">
				<h2>Menu</h2>
				<ul>
					        <li><a href="/posts">Archive</a></li>
        <li><a href="/tags">Tags</a></li>

				</ul>
			</nav>

			<!-- Main -->
			<div id="main">
				<div class="inner">

    
<header>
    <h1>Dissecting the Azure Service Fabric Mesh Right-Click Publish</h1>
            <p><em>Published on Monday, 15 October 2018</em></p>
            <ul class="actions small">
                    <li><a role="button" href="/tags/net" class="button small">.NET</a></li>
                    <li><a role="button" href="/tags/azure" class="button small">Azure</a></li>
                    <li><a role="button" href="/tags/service-fabric" class="button small">Service Fabric</a></li>
        </ul>     
</header>

					
					<div id="content">
						

<h1 id="because-friends-dont-let-friends-do-right-click-publish">Because friends don't let friends do right-click publish</h1>
<blockquote class="blockquote">
<p>This is not a post on why you should not do right-click publish, but rather a post on how to avoid it when working with Azure Service Fabric Mesh. If you want an answer for the why part, please read <a href="https://damianbrady.com.au/2018/02/01/friends-dont-let-friends-right-click-publish/">Damian Brady's blog post</a> on the subject.</p>
</blockquote>
<p>If you've ever looked at the <a href="https://docs.microsoft.com/en-us/azure/service-fabric-mesh/">Azure Service Fabric Mesh tutorials</a>, you've probably noticed that they only show you how to do right-click publish (or deploy pre-made ARM-templates). In order to understand how to avoid right-click publish, we'll need to understand what right-click publish does. Therefore, in this blog post we're going to dissect the right-click publish feature of <a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.ServiceFabricMesh">Service Fabric Mesh Tools for Visual Studio</a>. Before I started any practical work, which eventually lead to this blog post, I had a rough idea on how to bypass right-click publish when working with Azure Service Fabric Mesh solutions and Visual Studio, namely:</p>
<ul>
<li>Create docker images for each service in the application</li>
<li>Push the docker images to an Azure Container Registry</li>
<li>Generate an ARM template</li>
<li>Deploy the Azure Service Fabric Mesh application using the generated ARM template</li>
</ul>
<p>I knew that the Service Fabric Mesh Tools was accountable for some of the &quot;magic&quot;, while the <a href="https://www.nuget.org/packages/Microsoft.VisualStudio.Azure.SFApp.Targets">Service Fabric MSBuild targets</a> was accountable the rest. Because I'm more comfortable with debugging MSBuild than reverse-engineering Visual Studio extensions, the natural starting point was investigating the MSBuild targets and see how far it would take me.</p>
<p>In the following sections I will use the <code>todolistapp</code> sample located <a href="https://github.com/Azure-Samples/service-fabric-mesh/tree/c3da5474a67d635565a092ed9090442888142f9f/src/todolistapp">here</a>. So if you'd like to follow along, make sure you clone the <a href="https://github.com/Azure-Samples/service-fabric-mesh">Service Fabric Mesh Samples repository</a>.</p>
<h2 id="investigating-msbuild-targets">Investigating MSBuild Targets</h2>
<p>There are many ways to debug MSBuild, one  way to find all targets is to use the preprocess switch with MSBuild. MSBuild help says the following about the preprocess switch:</p>
<blockquote class="blockquote">
<p>/preprocess[:file]
Creates a single, aggregated project file by
inlining all the files that would be imported during a
build, with their boundaries marked. This can be
useful for figuring out what files are being imported
and from where, and what they will contribute to
the build. By default the output is written to
the console window. If the path to an output file
is provided that will be used instead.
(Short form: /pp)
Example:
/pp:out.txt</p>
</blockquote>
<p>We run the following command and then inspect the <code>out.xml</code> file.</p>
<pre><code class="language-cmd">msbuild /r /pp:out.xml todolistapp\todolistapp.sfaproj
</code></pre>
<p>While inspecting the <code>out.xml</code> file, we'll find two targets which are of special interest; <code>SFAppBuildApplication</code> and <code>SFAppPackageApplication</code>. I also remember seeing these two targets when skimming through the Service Fabric Mesh Tools logs in Visual Studio.</p>
<h2 id="building-service-fabric-mesh-application">Building Service Fabric Mesh Application</h2>
<p>Let's try out the first target then, run:</p>
<pre><code class="language-cmd">msbuild /r /t:todolistapp:SFAppBuildApplication /p:Configuration=Release;Platform=&quot;Any CPU&quot;
</code></pre>
<p>In the logs, we can see that the above target will find all services and build docker images, which is exactly what we want! We can see that it is naming and tagging our images like <code>webfrontend:dev</code> and <code>todoservice:dev</code>.</p>
<pre><code class="language-cmd">  docker build -f &quot;C:\Users\mb\src\gh\service-fabric-mesh\src\todolistapp\WebFrontEnd\Dockerfile&quot; -t webfrontend:dev &quot;C:\Users\mb\src\gh\service-fabric-mesh\src\todolistapp&quot;
  Sending build context to Docker daemon   3.52MB

  Step 1/16 : FROM microsoft/dotnet:2.1-aspnetcore-runtime-nanoserver-sac2016 AS base
   ---&gt; b1d6aab503b4
   ---&gt; d35f8074bc6a

  ...

  Step 16/16 : ENTRYPOINT [&quot;dotnet&quot;, &quot;WebFrontEnd.dll&quot;]
   ---&gt; Running in 95c5976daa00
  Removing intermediate container 95c5976daa00
   ---&gt; 915e93d027a6
  Successfully built 915e93d027a6
  Successfully tagged webfrontend:dev
</code></pre>
<p>The above step solved the first issue for us, it created docker images for each service in the application. While we could have searched for all dockerfile's ourselves and run <code>docker build</code>, I find the MSBuild target a little more helpful.</p>
<h2 id="push-the-docker-images-to-an-azure-container-registry">Push the docker images to an Azure Container Registry</h2>
<p>Next thing to do is to push our newly created docker images to a container registry. If you don't already have an Azure Container Registry, please follow the steps <a href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal">here</a> to create one and obtain the access keys (login server, username and password). Now, to push our local docker images to the Azure Container Registry, we'll just follow some of the examples found <a href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-docker-cli">here</a>.</p>
<p>First we'll use <a href="https://docs.docker.com/engine/reference/commandline/tag/">docker tag</a> to create aliases of our local images (replace <code>todolistappacr</code> with the name of your container registry):</p>
<pre><code class="language-cmd">docker tag webfrontend:dev todolistappacr.azurecr.io/webfrontend:1.0
docker tag todoservice:dev todolistappacr.azurecr.io/todoservice:1.0
</code></pre>
<p>Next, we'll need to login to the Azure Container Registry and push our images (replace <code>todolistappacr</code>with the name of your container registry).</p>
<pre><code class="language-cmd">docker login todolistappacr.azurecr.io -u username -p password
docker push todolistappacr.azurecr.io/webfrontend:1.0
docker push todolistappacr.azurecr.io/todoservice:1.0
</code></pre>
<h2 id="packaging-service-fabric-mesh-application">Packaging Service Fabric Mesh Application</h2>
<p>Now that we have pushed the docker images to our container registry, we can start preparing the Azure Service Fabric Mesh application. For this, we'll call <code>msbuild</code> with the <code>SFAppPackageApplication</code> target.</p>
<pre><code class="language-cmd">msbuild /r /t:todolistapp:SFAppPackageApplication /p:Configuration=Release;Platform=&quot;Any CPU&quot;
</code></pre>
<p>The above target will find all <code>yaml</code>-files and pass them to a tool called <code>SfSbzYamlMerge.exe</code>. The tool will merge all <code>yaml</code>-files and output a <code>json</code>-file (<code>merged-arm_rp.json</code>). This <code>json</code>-file is the ARM (Azure Resource Manager) template we are going to use for publishing our Service Fabric Mesh application to Azure. If we try to diff the <code>merged-arm_rp.json</code> file to the one Visual Studio leaves behind after doing right-click publish, we'll notice some differences.</p>
<pre><code class="language-diff">--- bin/Release/SBZPkg/merged-arm_rp.json       2018-10-11 21:46:46.967348000 +0300
+++ bin/Debug/SBZPkg/merged-arm_rp.json 2018-10-11 17:38:36.497734800 +0300
&#64;&#64; -8,6 +8,10 &#64;&#64;
       &quot;metadata&quot;: {
         &quot;description&quot;: &quot;Location of the resources.&quot;
       }
+    },
+    &quot;registryPassword&quot;: {
+      &quot;defaultValue&quot;: &quot;&quot;,
+      &quot;type&quot;: &quot;SecureString&quot;
     }
   },
   &quot;resources&quot;: [
&#64;&#64; -29,7 +33,7 &#64;&#64;
               &quot;codePackages&quot;: [
                 {
                   &quot;name&quot;: &quot;WebFrontEnd&quot;,
-                  &quot;image&quot;: &quot;webfrontend:dev&quot;,
+                  &quot;image&quot;: &quot;todolistappacr.azurecr.io/webfrontend:20181011173823&quot;,
                   &quot;endpoints&quot;: [
                     {
                       &quot;name&quot;: &quot;WebFrontEndListener&quot;,
&#64;&#64; -55,6 +59,11 &#64;&#64;
                       &quot;cpu&quot;: 0.5,
                       &quot;memoryInGB&quot;: 1.0
                     }
+                  },
+                  &quot;imageRegistryCredential&quot;: {
+                    &quot;server&quot;: &quot;todolistappacr.azurecr.io&quot;,
+                    &quot;username&quot;: &quot;todolistappacr&quot;,
+                    &quot;password&quot;: &quot;[parameters('registryPassword')]&quot;
                   }
                 }
               ],
&#64;&#64; -74,7 +83,7 &#64;&#64;
               &quot;codePackages&quot;: [
                 {
                   &quot;name&quot;: &quot;ToDoService&quot;,
-                  &quot;image&quot;: &quot;todoservice:dev&quot;,
+                  &quot;image&quot;: &quot;todolistappacr.azurecr.io/todoservice:20181011173823&quot;,
                   &quot;endpoints&quot;: [
                     {
                       &quot;name&quot;: &quot;ToDoServiceListener&quot;,
&#64;&#64; -92,6 +101,11 &#64;&#64;
                       &quot;cpu&quot;: 0.5,
                       &quot;memoryInGB&quot;: 1.0
                     }
+                  },
+                  &quot;imageRegistryCredential&quot;: {
+                    &quot;server&quot;: &quot;todolistappacr.azurecr.io&quot;,
+                    &quot;username&quot;: &quot;todolistappacr&quot;,
+                    &quot;password&quot;: &quot;[parameters('registryPassword')]&quot;
                   }
                 }
               ],
</code></pre>
<p>The ARM template generated by Visual Studio takes a parameter called <code>registryPassword</code> and the images in the code packages for each service seems to point at our Azure Container Registry, while our ARM template just uses <code>todoservice:dev</code> (the default name and tag created by the MSBuild targets). The Visual Studio generated ARM template also has a <code>imageRegistryCredential</code> in each code package. We'll need to update our ARM template with the changes seen above. Make sure you use the correct registry server and username, also make sure to use the same tag of the docker image as we used when we pushed the images (we used <code>1.0</code> in the example previously. So change <code>20181011173823</code> to <code>1.0</code>).</p>
<h2 id="deploy-the-azure-service-fabric-mesh-application-using-the-generated-arm-template">Deploy the Azure Service Fabric Mesh application using the generated ARM template</h2>
<p>Now that we have created our ARM template, we are ready to publish our Service Fabric Mesh application to Azure. We'll use the same commands as can be found in the <a href="https://docs.microsoft.com/en-us/azure/service-fabric-mesh/service-fabric-mesh-tutorial-template-deploy-app">Service Fabric Mesh Tutorial</a>.</p>
<p>First, Login to Azure</p>
<pre><code class="language-cmd">az login
</code></pre>
<p>Then, create a resource group</p>
<pre><code class="language-cmd">az group create -l eastus -n todolistapp-rg
</code></pre>
<p>Last, create the deployment (replace <code>password</code> with the password to your Azure Container Registry).</p>
<pre><code class="language-cmd">az mesh deployment create --resource-group todolistapp-rg --template-file todolistapp\bin\Release\SBZPkg\merged-arm_rp.json --name todolistapp --parameters location=eastus registryPassword=password
</code></pre>
<p>You may follow the progress of the deployment in Azure Portal, but after a couple of minutes you should see that the application have been successfully deployed.</p>
<pre><code class="language-cmd">Deploying . . .
application todolistapp has been deployed successfully on network todolistappNetwork with public ip address 40.76.208.91
To recieve additional information run the following to get the status of the application deployment.
az mesh app show --resource-group todolistapp-rg --name todolistapp
</code></pre>
<p>Now, just open a browser and head over to the IP address and see your application in action. Make sure to also specify the correct port. The sample use <code>20006</code> as default, so in the above example I'd open my browser and go to <a href="http://40.76.208.91:20006/.">http://40.76.208.91:20006/.</a></p>
<h2 id="conclusion">Conclusion</h2>
<p>While we got pretty far by just using the msbuild targets located in <code>Microsoft.VisualStudio.Azure.SFApp.Targets</code> we still need to do some manual work with pushing docker images and modifying the ARM-template. AFAIK, the msbuild targets don't understand publish profile <code>yaml</code>-files as these are solely intended to be used with the Visual Studio Tooling (ie. right-click deploy). We still have some work to do before we can deploy Service Fabric Mesh applications from our CI/CD pipeline. However, if it can be documented, it can be automated. Therefore, stay tuned for a follow up blog post on how to automate the above steps with <a href="https://cakebuild.net/">Cake</a>.</p>



					</div>
				</div>
			</div>

			<!-- Footer -->
			<footer id="footer">
				<div class="inner">
    <section>
        <h2>Feeds</h2>
        <ul class="actions small vertical">
            <li><a href="/feed.rss" class="button small"><i class="fa fa-rss"></i> RSS Feed</a></li>
                        <li><a href="/feed.atom" class="button small"><i class="fa fa-rss"></i> Atom Feed</a></li>
        </ul>
    </section>
    <section>
    </section>
    <ul class="copyright">
        <li>Copyright © 2019</li>
        <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
        <li><a href="https://wyam.io">Generated by Wyam</a></li>
    </ul>
</div>

			</footer>

		</div>
		
		<script type="text/javascript">
    // Google Analytics
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-121782933-1', 'auto');
    ga('send', 'pageview');
</script>

		<!-- Scripts -->
		<script>hljs.initHighlightingOnLoad();</script>
		<script src="/assets/js/jquery.min.js"></script>
		<script src="/assets/js/skel.min.js"></script>
		<script src="/assets/js/util.js"></script>
		<!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js"></script><![endif]-->
		<script src="/assets/js/main.js"></script>

	</body>

</html>
